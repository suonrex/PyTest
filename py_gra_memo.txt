GRAMMAR1:Package
①	A directory must contain a file named "__init__.py" in order for Python to consider it as a package. 
	Game(Pac)->__init__.py
			->Sound(Sub_Pac)->__init__.py
							->load.py/play.py/pause.py/etc..
			->Image(Sub_Pac)->__init__.py
							->open.py/change.py/close.py/etc..
			->Level(Sub_Pac)->__init__.py
							->start.py/load.py/over.py/etc..

②	Importing module from a package
	>>import Game.Level.start

	Now if this module contains a function named select_difficulty(), we must use the full name to reference it.
	>>Game.Level.start.select_difficulty(2)

	If this construct seems lengthy, we can import the module without the package prefix as follows.
	>>from Game.Level import start

	We can now call the function simply as follows.
	>>start.select_difficulty(2)

	Yet another way of importing just the required function (or class or variable) form a module within a package would be as follows.
	>>from Game.Level.start import select_difficulty

	Now we can directly call this function
	select_difficulty(2)

	※Although easier, this method is not recommended! Using the full "namespace" avoids confusion and prevents two same identifier names from colliding.

GRAMMAR2:Type　and Math
①	While integers can be of any length, a floating point number is accurate only up to 15 decimal places 	(the 16th place is inaccurate)(只能精确到·15·位)
	Example:
	a = 5

	# Output: <class 'int'>
	print(type(a))

	# Output: <class 'float'>
	print(type(5.0))

	# Output: (8+3j)
	c = 5 + 3j
	print(c + 3)

	# Output: True
	print(isinstance(c, complex))

②	Number system prefix for Python numbers
	Number System　=> Prefix
	Binary(2)	=>	'0b' or '0B'
	Octal(8)	=>	'0o' or '0O'
	Hexadecimal(16)	=>	'0x' or '0X'

	Example:
	# Output: 107
	print(0b1101011)

	# Output: 253 (251 + 2)
	print(0xFB + 0b10)

	# Output: 13
	print(0o15)

③	coercion(强制转换):
	>>> 1 + 2.0
	3.0

	>>> int(2.3)
	2
	>>> int(-2.8)
	-2
	>>> float(5)
	5.0
	>>> complex('3+5j')
	(3+5j)
	※tips:When converting from float to integer, the number gets truncated (integer that is closer to zero).

④	mod(取余) 使商最小
	print(-7 % 3 ) => 2
	print(7 % -3) => -2
	print(-7%-3) => -1

⑤	Python Decimal(十进制)
	>>> (1.1 + 2.2) == 3.3
	False
	↑
	Reason:	most of the decimal fractions we know, cannot be accurately stored in our computer.
			We cannot represent the fraction 1/3 as a decimal number. This will give 0.33333333... which is infinitely long, and we can only approximate it.

	>>> 1.1 + 2.2
	3.3000000000000003

	to carry out decimal calculations,use decimal.Decimal
	Example:
	from decimal import Decimal as D
	# Output: Decimal('3.3')
	print(D('1.1') + D('2.2'))

	# Output: Decimal('3.000')
	print(D('1.2') * D('2.50'))

⑥	Python Fractions(分数)
	Example1:
	import fractions

	# Output: 3/2
	print(fractions.Fraction(1.5))

	# Output: 5
	print(fractions.Fraction(5))

	# Output: 1/3
	print(fractions.Fraction(1,3))

	Example2:
	from fractions import Fraction as F

	# Output: 2/3
	print(F(1,3) + F(1,3))

	# Output: 6/5
	print(1 / F(5,6))

	# Output: False
	print(F(-3,10) > 0)

	# Output: True
	print(F(-3,10) < 0)

⑦	Python Mathematics
	Python offers modules like math and random to carry out different mathematics like trigonometry(三角函数), logarithms(对数), probability and statistics(概率与统计), etc.

GRAMMAR3:Nested Dictionarty
	Key Points to Remember:
		1 Nested dictionary is an unordered collection of dictionary(无序)
		2 Slicing Nested Dictionary is not possible.(不可分割)
		3 We can shrink or grow nested dictionary as need.(可增删)
		4 Like Dictionary, it also has key and value.(和字典类似，有索引和值)
		5 Dictionary are accessed using key.(通过索引访问)

GRAMMAR4: Array(数组)
	type codes:
		Type code	C Type			Python Type		Minimum size in bytes
			'b'		signed char			int				1
			'B'		unsigned char		int				1
			'u'		Py_UNICODE		Unicode character	2
			'h'		signed short		int				2
			'H'		unsigned short		int				2
			'i'		signed int			int				2
			'I'		unsigned int		int				2
			'l'		signed long			int				4
			'L'		unsigned long		int				4
			'f'		float 				float			4
			'd'		double				float			8

	# When to use arrays?(尽量不用)
	Lists are much more flexible than arrays. They can store elements of different data types including string. Also, lists are faster than arrays. And, if you need to do mathematical computation on arrays and matrices, you are much better off using something like NumPy library.

	Unless you don't really need arrays (array module may be needed to interface with C code), don't use them.

GRAMMAR5: Matrices
	To multiply two matrices, we use dot() method. 
	Note: * is used for array multiplication (multiplication of corresponding elements of two arrays) not matrix multiplication.

GRAMMAR6: List Comprehension
	[expression for item in list]
		↓			↓		↓
	[ letter for letter in 'human' ]

	Example:
	matrix = [[1, 2], [3,4], [5,6], [7,8]]
	transpose = [[row[i] for row in matrix] for i in range(2)]
	print (transpose)
	// output:[[1, 3, 5, 7], [2, 4, 6, 8]]
	# **Note: The nested loops in list comprehension don’t work like normal nested loops. 
	# In the program, for i in range(2) is executed before row[i] for row in matrix. 
	# Hence at first, a value is assigned to i then item directed by row[i] is appended in the transpose variable.

	Key Points to Remember:
		1 List comprehension is an elegant way to define and create lists based on existing lists.
		2 List comprehension is generally more compact and faster than normal functions and loops for creating list.
		3 However, we should avoid writing very long list comprehensions in one line to ensure that code is user-friendly.
		4 Remember, every list comprehension can be rewritten in for loop, but every for loop can’t be rewritten in the form of list comprehension.

GRAMMAR　7: Python File Modes
	Mode	Description
	'r'	Open a file for reading. (default)
	'w'	Open a file for writing. Creates a new file if it does not exist or truncates the file if it exists.
	'x'	Open a file for exclusive creation. If the file already exists, the operation fails.
	'a'	Open for appending at the end of the file without truncating it. Creates a new file if it does not 	exist.
	't'	Open in text mode. (default)
	'b'	Open in binary mode.
	'+'	Open a file for updating (reading and writing)

	Example:
	f = open("test.txt")      # equivalent to 'r' or 'rt'
	f = open("test.txt",'w')  # write in text mode
	f = open("img.bmp",'r+b') # read and write in binary mode

GRAMMAR　8: Python File Methods
	Method						Description
	close()						Close an open file. It has no effect if the file is already closed.
				
	detach()					Separate the underlying binary buffer from the TextIOBase and return it.
				
	fileno()					Return an integer number (file descriptor) of the file.
			
	flush()						Flush the write buffer of the file stream.
			
	isatty()					Return True if the file stream is interactive.
			
	read(n)						Read atmost n characters form the file. Reads till end of file if it is 							negative or None.			
			
	readable()					Returns True if the file stream can be read from.
			
	readline(n=-1)				Read and return one line from the file. Reads in at most n bytes if 								specified.
			
	readlines(n=-1)				Read and return a list of lines from the file. Reads in at most n bytes/characters 					if specified.

	seek(offset,from=SEEK_SET)	Change the file position to offset bytes, in reference to from (start, 								current, end).

	seekable()					Returns True if the file stream supports random access.

	tell()						Returns the current file location.

	truncate(size=None)			Resize the file stream to size bytes. If size is not specified, resize 								to current location.

	writable()					Returns True if the file stream can be written to.

	write(s)					Write string s to the file and return the number of characters written.

	writelines(lines)			Write a list of lines to the file.

GRAMMAR　9: Python Directory
	>>> import os

	# get the present working directory using the getcwd() method
	>>> os.getcwd()
	'C:\\Program Files\\PyScripter'
	
	# deprecated in windows(not recommended)
	>>> os.getcwdb()
	b'C:\\Program Files\\PyScripter'

	>>> print(os.getcwd())
	C:\Program Files\PyScripter

	# Changing Directory
	>>> os.chdir('C:\\Python33')

	# List Directories and Files
	>>> os.listdir()
	['DLLs', 'Doc', 'get-pip.py', 'include', 'Lib', 'libs', 'LICENSE.txt', 'NEWS.txt', 'numpy-1.16.1-cp37-cp37m-win32.whl', 'python.exe', 'python3.dll', 'python37.dll', 'pythonw.exe', 'Scripts', 'site-packages', 'tcl', 'Tools', 'vcruntime140.dll']
	>>> os.listdir('C:\\')
	['$Recycle.Bin', '$WINDOWS.~BT', '$Windows.~WS', 'Apl', 'autoexec.bat', 'config.sys', 'Documents and Settings', 'hiberfil.sys', 'MSOCache', 'mysql-5.7.20-win32', 'pagefile.sys', 'PerfLogs', 'Program Files', 'ProgramData', 'Recovery', 'System Volume Information', 't1ro.2', 'Users', 'Windows']

	# Making a New Directory
	>>> os.mkdir('test')
	# Rename a Directory
	>>> os.rename('test','newone')
	# remove a Directory(only for empty Dir)
	>>> os.rmdir('newone')

	# In order to remove a non-empty directory we can use the rmtree() method inside the shutil module.
	>>> import shutil

	>>> shutil.rmtree('test')
	>>> os.listdir()
	[]

GRAMMAR 10:Python Errors and Built-in Exceptions
	1　Error caused by not following the proper structure (syntax) of the language is called syntax error or parsing error.
	2 Errors can also occur at runtime and these are called exceptions. They occur, for example, when a file we try to open does not exist (FileNotFoundError), dividing a number by zero (ZeroDivisionError), module we try to import is not found (ImportError) etc.

	3 Built-in functions 
	# We can view all the built-in exceptions using the local() built-in functions as follows.
	>>>locals()['__builtins__']
	
	To know more access
	https://www.programiz.com/python-programming/exceptions

GRAMMAR 11:Python Exception Handling - Try, Except and Finally
	# Catching Specific Exceptions in Python
	Example:
	try:
    # do something
	   pass

	except ValueError:
	   # handle ValueError exception
	   pass

	except (TypeError, ZeroDivisionError):
	   # handle multiple exceptions
	   # TypeError and ZeroDivisionError
	   pass

	except:
	   # handle all other exceptions
	   pass

	 # Raising Exceptions
	 >>> raise KeyboardInterrupt
	Traceback (most recent call last):
	...
	KeyboardInterrupt

	>>> raise MemoryError("This is an argument")
	Traceback (most recent call last):
	...
	MemoryError: This is an argument

	>>> try:
	...     a = int(input("Enter a positive integer: "))
	...     if a <= 0:
	...         raise ValueError("That is not a positive number!")
	... except ValueError as ve:
	...     print(ve)
	...    
	Enter a positive integer: -2
	That is not a positive number!

	# try...finally
	try:
   		f = open("test.txt",encoding = 'utf-8')
   	# perform file operations
	finally:
   		f.close()

GRAMMAR 12:Python Object Oriented Programming
① Intruduction　
An object has two characteristics:
	attributes
	behavior	
The concept of OOP in Python focuses on creating reusable code. This concept is also known as DRY (Don't Repeat Yourself).

In Python, the concept of OOP follows some basic principles:
	Inheritance :A process of using details from a new class without modifying existing class.
	Encapsulation :Hiding the private details of a class from other objects.
	Polymorphism :A concept of using common operation in different ways for different data input.

Example:
class Parrot:
    pass